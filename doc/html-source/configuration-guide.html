    <!-- configuration-guide +++++++++++++++++++++++++++++++++++++++++++++ -->

    <A NAME="configuration-guide"></A>
    <H1 ALIGN="CENTER">Configuration guide</H1>
    <HR WIDTH="70%">
    <h2 align="center">About this guide</h2>
    <p>
    This guide tries to describe the basic configuration steps for
    commonly used hardware.  It's focused on the basic usage scenario
    to get the remote up and running, the more advanced features are
    not covered. This includes irexec, lircmd, ir blasting and the
    TCP/IP-based remote features.
    </p>
    <A NAME="why-use-lirc"></A><HR>
    <h2 align="center">Why should I use LIRC?</h2>
    <p>
    Recent kernels have built-in support for IR remotes. Using that,
    pressing an up-arrow on the remote works the same way as pressing the
    up-arrow on a keyboard. This is a modern "just works" solution. On
    the other hand, LIRC is an old style linux application which can be
    tweaked to do almost anything, but is tricky to setup. So, why
    would you use LIRC?
    <ul>
      <li>
        You might have a remote which is supported by LIRC but not the kernel.
        </li>
      <li>
        If you have a remote which isn't supported at all, LIRC is probably
        your best bet to get it running. </li>
      <li>
        You might have an application which is more or less designed to use
        LIRC. </li>
      <li>
        You might need LIRC's capabilities e. g., modes where a single
        remote button can be teached to deliver different keys to the
        application. </a>
      <li>
        You might want to send IR signals to other devices (IR blasting).
        </li>
      <li>
        You might need LIRC's way of delivering application-specific events
        for remote buttons - handling several applications with one remote
        is easier with LIRC. </li>
      <li>
        You might need LIRC's way of delivering the events to several
        applications instead of just one. E. g., you can use irexec(1)
        to run arbitrary commands in parallel with an application such as
        mythtv or xbmc.</li>
    </ul>
    <p>
    So, while the kernel built-in handling works out of the box in many
    cases, there are still scenarios when LIRC is the right tool.
    </p>

    <A NAME="overall-configuration-decisions"></A><HR>
    <h2 align="center">Overall Configuration Decisions.</h2>
    <pre>
       ----------         ---------------------               ----------
       |        |         |                   |               |        |
       |        |---->----| Linux input layer |------->-------| Appli- |
       |        |         |                   |  /dev/input   | cation |
       |        |         ---------------------               |        |
--->---| kernel |                |        |                   ----------
remote |        |       devinput v        |
       |        |                |        ^ uinput
       |        |                |        |                   ----------
       |        |         ---------------------               | Appli- |
       |        |---->----|      lirc         |------->-------| cation |--
       |        |         |                   | /var/run/lirc |        | |
       ----------         ---------------------               ---------- |--
                                                                |        | |
                                                                ---------- |
                                                                  |        |
                                                                  ----------
    </pre>
    <p>
    LIRC can be run together with the kernel in different ways. You need
    to decide on a general approach first.
    </p>
    <p>
    Depending on whether lirc is used or not application will get data
    either from the input layer (/dev/input) or from LIRC (/var/run/lirc).
    Using the LIRC data requires application support. Support for LIRC
    is common in typical linux htpc applications like mythtv, xbmc and vlc.
    </p>
    <p>
    The /var/run/lirc interfaces allows several applications to receive
    input events. On the other hand, the /dev/input interfaces only allows
    one  application to receive the events.
    </p>
    <ul><li>
    A common scenario is to not involve lirc at all, the upmost
    path in the picture (kernel -&gt Linux input layer -&gt application).
    Unless there is reason to use lirc <a href="#why-use-lirc">(above)</a>)
    this is probably the way to go.
    </ul></li>
    <p>
    If you need to use lirc, there is two cases depending on if your
    remote is supported by the kernel or not.
    </p>
    <ul>
    <li>
    If it's supported, you should probably at least first try using the
    linux input layer decoding and use that as input to lirc. This is the
    devinput data path in picture (kernel -&gt Linux input layer -&gt lirc
    -&gt app).
    </li>
    <li>
    If the kernel built-in decoding can't be used you need to use a lirc
    driver instead. This is the bottom data path (kernel -&gtlirc -&gt app).
    </li>
    </ul>
    <p>
    Last option is to connect the LIRC driver to the linux input layer
    using LIRC's --uinput option. This means that application sees the
    input as coming from the kernel, and LIRC's other capabilities are
    not available. This is not described here.
    </p>
    <A NAME="basic-setup-flow"></A><HR>
    <h2 align="center">Basic setup flow</h2>
    <pre>
      ------------                   Often needs a device e. g.,
      |  driver  |                   /dev/input/eventXX
      ------------
           |
           v  IR pulse data          Use mode2(1) to debug.
           |
   ----------------
   |  lirc pass 1 |                  lircd.conf config file.
   ----------------
           |
           v  Key symbols            Use irw(1) to debug.
           |
   ----------------
   |  lirc pass 2 |                  lircrc config file.
   ----------------
           |
           v  Application strings    Use ircat(1) to debug.
           |

      Applications
    </pre>

    The setup consists of three parts.
    <ul>
       <li> <A HREF="#determine-driver-and-device">Determine driver and
         device</a></li>
       <li> Convert IR pulse data from the driver to key symbols either using
          <A HREF="#key-symbols-using-linux-input-layer">the linux input
          layer</a> or <A HREF="#key-symbols-using-lirc-drivers">an lirc
          driver</a> using the lircd.conf file.</li>
       <li><A HREF="#converting-key-symbols-to-application-strings">
          Convert the key symbols to application strings</a> using the
          ~/.lircrc file.</li>
    </ul>
    <A NAME="determine-driver-and-device"></A><HR>
    <h3 align="center">Determine driver and device</h3>
    <p>
    To determine the driver to use you might need to know the name of your
    device, what module the kernel has loaded for it and the device
    it's connected to.</p>
    <p>
    The first thing to do is to invoke ir-keytable:
    <pre>
    $ ir-keytable
    Found /sys/class/rc/rc0/ (/dev/input/event11) with:
        Driver em28xx, table rc-pinnacle-pctv-hd
        Supported protocols: NEC RC-5 RC-6
        Enabled protocols: RC-5
        Extra capabilities: <access denied>
    </pre> </li>
    If you get this kind of output you know the event device
    (/dev/input/event11) and the kernel module loaded (em28xx).
    Furthermore, since ir-keytable finds the device you know that the
    driver is part of the rc subsystem.  Not all devices are recognized
    by ir-keytable, though.</p>
    <p>
    Next step is inspect dmesg, possibly after reconnecting your device.
    If you have a standard IR remote which is recognized by the kernel
    you can find how it's registered as rc0. In this case you don't need
    any name - ir-keytable provides all necessary info.
    <pre>
     usb 3-2: Product: eHome Infrared Transceiver
     Registered IR keymap rc-rc6-mce
     input: Media Center Ed. eHome Infrared Remote Transceiver (0609:031d)
          as /devices/pci0000:00/0000:00:14.0/usb3/3-2/3-2:1.0/rc/rc0/input16
     rc0: Media Center Ed. eHome Infrared Remote Transceiver (0609:031d)
          as /devices/pci0000:00/0000:00:14.0/usb3/3-2/3-2:1.0/rc/rc0
     input: MCE IR Keyboard/Mouse (mceusb) as /devices/virtual/input/input17
     rc rc0: lirc_dev: driver ir-lirc-codec (mceusb) registered at minor = 0
   </pre>
    </p>
    If you find something like this you have a device which isn't an ir
    device, with a 'X10' in the name (in this case an RF remote)
    <pre>
        usb 2-2: Product: RF receiver
        usb 2-2: Manufacturer: X10 WTI
    </pre>
    Even if you have an ir device, you might see something like this if the
    kernel sees it as a keyboard rather than a remote. Here, an usb
    keyboard from JITTEL:
    <pre>
    Product: JTTEL Composite Devices
    hid-generic 0003:20E8:5820.0001: input,hidraw0: USB HID v10.01 Keyboard
        [JTTEL Inc. JTTEL Composite Devices] on usb-0000:00:1d.1-1/input0
    </pre>
    </p>
    <p>
    For devices like these which not are registered as rc devices (and thus
    not recognized by ir-keytable) you need to find out the corresponding
    event device as described in <a href="#appendix-2">Appendix 2</a> .</p>
    <p>
    Knowing the device name, the kernel module loaded (if any) and perhaps also
    a /dev/input device you have to select a driver:
    <ul>
       <li>
         If ir-keytable located the device you can use the devinput driver.
         This means that the kernel decodes the ir signals and converts them
         to button press symbols. Use something like (with device as from
         ir-keytable):
         <pre>
                --driver devinput --device /dev/input/event11
         </pre></li>
       <li>
         If you dont wan't to use the decoding done by the kernel, but the
         device is recognized by ir-keytable you can have lirc decode the
         raw signal from the driver. This means using the default driver
         which is accesible on a /dev/lirc device, normally /dev/lirc0.
         Use something like:
         <pre>
               --driver default --device /dev/lirc0
         </pre></li>
       <li>
         if you can find the device name and/or the module in the
         <a href="http://www.lirc.org/html/table.html">driver list </a>
         you might try to use this driver.  Refer to <a href="#appendix-3">
         Appendix 3</a> for details.</li>
       <li>
         If you have a device such as a keyboard which is not recognized
         and can't find a driver in the driver list, your only option is
         using the devinput driver (above).</li>
     </ul>
     If you are to use the devinput driver, read on. Otherwise proceed to
     <A HREF="#key-symbols-using-lirc-drivers">Getting the key symbols using
     lirc driver</A>


    <A NAME="key-symbols-using-linux-input-layer"></A>
    <A NAME="getting-the-key-symbols-using-linux-input-layer"></A><HR>
    <h3 align="center">Getting the key symbols using linux input layer</h3>
    <pre>
  -----------------
  |    kernel     |
  -----------------
        |
        v
        |
  -----------------
  |  input layer  |
  -----------------
        |
        v  /dev/input/eventX         Use ir-keytable to manage and debug
        |
  ----------------
  |    lirc      |                   Use devinput driver
  |              |                   Use lircd.conf.devinput
  ----------------
        |
        v  key symbols               Use irw to debug
        |

    </pre>
    <p>
    If you're lucky, your remote is already supported by the kernel. In
    order to find out, the first task is to locate the event device,
    something like /dev/input/event12 which is connected to your IR
    device. This is described in <a href="#appendix-2">appendix 2</a>.
    </p>
    <p>
    With the device known use ir-keytable to test if your remote works:
    <pre>
    # ir-keytable -t -d /dev/input/event13
    </pre>
    Press buttons on the remote. If it starts to print out scan codes
    and key symbols everything is fine. Otherwise, try to change the
    protocol (see the ir-keytable manpage). If this doesn't work, it
    might be the end of the road and you might need to use the lirc
    driver option instead.
    </p>
    <p>
    Check that all buttons generate output when testing. If there are
    buttons which are not mapped (no key symbol) you might not be
    able to fix this unless you go for the lirc driver option (to change
    the key symbol is perfectly possible, but probably not what you want
    here).
    </p>
    <p>
    Then, grab the devinput/lircd.conf.devinput file
    <a href="http://sourceforge.net/p/lirc/git/ci/master/tree/remotes/">
    (remotes) </a> and copy it to /etc/lirc/lircd.conf. Start the lircd
    daemon and use irw to check:
    <pre>
    $ lircd --device /dev/input/event13 --driver devinput
    $ irw
    </pre>
    Press remote buttons. You should see the key symbols being printed.
    When so you are done and can proceed to
    <A HREF="#key-symbols-to-app-strings">Convert key symbols to application
    strings</a>
    </p>
    <A NAME="key-symbols-using-lirc-drivers"></A><HR>
    <h3 align="center">Getting the key symbols using lirc drivers</h3>
    <pre>
  ---------------------------------
  |    kernel devices             |
  ---------------------------------
       |       | kernel rc driver |  Needs configuration
       |       -- -----------------
       |                  |
       v                  v          raw pulse data
       |                  |
  ---------------         |
  | LIRC driver |----------
  ---------------
       |
       v      pulses                 Use mode2 to debug.
       |
  ---------------
  | LIRC pass 1 |                    lircd.conf
  ---------------
       |
       v      keysyms                Use irw to debug
    </pre>
    <p>
      You have already determined the driver and perhaps device to use.
      Make sure the lirc driver can read the remote, and produce pulses:
    </p>
    <ul>
      <li>
      Choose a method to configure the kernel built-in handling,
      implement it and verify that it works <a href="#appendix-1">
      (Appendix 1)</a>. As a last step, fire-up your application
      and make sure the remote does not affect it in any way.</li>
      <li> Check using mode2(1), verify that you get pulses. </li>
      <li>
      Update the configuration file which is used by lircd to use
      the driver and device (/etc/sysconfig/lirc or
      /etc/lirc/hardware.conf on many systems) </li>
    </ul>
    <p>
       lirc pass 1: Using lircd.conf, convert pulses to key symbols
       like KEY_UP:
    </p>
    <ul>
      <li>
        Read the <a href="configure.html#lircd.conf">lircd.conf </a>
        chapter. Either use a pre-existing lircd.conf
        <a href="http://sourceforge.net/p/lirc/git/ci/master/tree/remotes/">
        (remotes)</a> or roll your own using <a href="irrecord.html">
        irrecord(1)</a>.</li>
      <li>
        If using a predefined lircd.conf, ensure it uses proper key symbols
        as listed by <em> irrecord -l</em> whenever it makes sense. Don't
        hesitate to replace the old ones not in namespace.
      <li>
        Install the lircd.conf and start lircd daemon using something like:
        <pre>
        $ lircd --driver default --device /dev/lirc0
        </pre>
        Verify the results using irw(1). Check all buttons! </li>
    </ul>
    <A NAME="key-symbols-to-app-strings"></A>
    <A NAME="converting-key-symbols-to-application-strings"></A><HR>
    <h3 align="center">Converting key symbols to application strings</h3>
    <pre>
       |
       v      keysyms                Use irw to debug.
       |
  ---------------
  | LIRC pass 2 |                     ~/.lircrc
  ---------------
       |
       |      /var/run/lirc/lircX
       v      config strings
       |                             Use ircat to debug.
       |
  ---------------
  | Application |
  ---------------
</pre>
    <p> By now you should know the driver and device used when running
       lircd. Update the configuration files used to control the service
       with these (e. g., /etc/sysconfig/lirc or /etc/lirc/hardware.conf).
       </p>
    <ul><li>
      Check that you can start/stop a working service, irw is your friend.
    </li></ul>
    <p>Using ~/.lircrc, convert the key symbols to application-specific
      strings:
      <ul>
        <li> Read the <a href="configure.html#lircrc_format">.lircrc chapter
          </a> and create your ~/.lircrc.</li>
        <li>Restart the lircd daemon. Use <a href="ircat.html">ircat(1)</a>
            to verify your application settings i. e., what your
            application actually recieves when pushing the remote button.</li>
      </ul>
    </p>
    <p>Test the application, and investigate further steps:</p>
    <ul>
      <li> Configure your application to use the same socket as irw and
        test it.</li>
      <li>Once the application is up, you might want to exploit LIRC's
        capabilities: </li>
      <ul>
         <li>Using <a href="irexec.html">irexec(1)</a> you can configure
           lirc to run arbitrary program when a button is pressed.</li>
         <li> Using <a href="lircmd.html">lircmd(1)</a> you can use lirc
           to let the remote emulate a mouse. </li>
         <li>You can setup lirc to transmit IR signals (IR blasting) to
           other devices e. g., let the remote send ir signals to a TV
           set. The program is <a href="irsend.html">irsend(1)</a>, you
           might want to scan the web for howto:s.</li>
       </ul>
    </ul>
    <A NAME="appendixes"></A><HR>
    <h2 align="center"> Appendixes</h2>

    <A NAME="appendix-1"></A>
    <h3 align="center"> A1: Configuring the kernel</h3>
     <p>
     When using an LIRC ir driver, the kernel ir driver must be
     configured to send the data only to the /dev/lirc device and not
     to the general input layer. If not, each button event will delivered
     twice to the application, both through /var/run/lirc and /dev/input.
     </p>
     <p>
     Also, some lirc drivers conflicts with the kernel drivers. A common
     example is the lirc atilibusb driver which conflicts with the kernel
     ati_remote driver. Such conflicts shows up as dmesg output about not
     being able to open the involved device, plus various other symptoms.
     </p>
     <p>
     The kernel driver configuration can be done using the interfaces under
     /sys/class/rc or using a udev rule. Conflicting kernel drivers must
     be blacklisted. Conflicts on serial ports can be handled by disabling
     the kernel serial driver for that port.</p>
    <A NAME="kernel-driver-configuration"></A>
    <h4 align="center"> Kernel driver configuration.</h4>
    <p>
    The builtin ir driver subsystem is aware of LIRC, and is capable to send
    all data through /dev/lirc. To configure:
    <pre>
        # echo -- 'lirc' > /sys/class/rc/rc0/protocols
    </pre>
    Here, 'rc0' is OK if you have only one infrared device. Note that
    this is not persistent, you need to do this after each boot.  </p>
    <p>
    Using '-lirc' instead restores the normal kernel operation when
    stopping LIRC. </>
    <A NAME="udev-rules"></A>
    <h4 align="center">Udev rules</h4>
    <p>Instead of issuing commands, you can create a file
      /etc/udev/rules.d/99-remote-control-lirc like:
    <pre>
       SUBSYSTEM=="rc", ATTR{protocols}="lirc"
    </pre>
    This is persistent and makes all ir devices send data only
    through /dev/lirc where it can be retrieved by the 'default' driver.</p>
    <A NAME="blacklisting-modules"></A>
    <h4 align="center">Blacklisting modules.</h4>
    <p>
    When using remotes which are not infrared, the corresponding driver is
    not affected by the methods above. One example is an RF remote I have
    which uses the atilibusb LIRC driver. This conflicts with the ati_remote
    kernel module, which thus needs to be disabled. Do this by creating the
    file /etc/modprobe.d/blacklist-atiremote.conf like:
    <pre>
        # Conflicts with LIRC.
        blacklist ati_remote
    </pre>
    Finding out what module to blacklist is not always easy. dmesg(1)
    sometimes gives a hint about conflicts on a device. Another method is
    to boot the system without the usb device connected, and do a lsmod.
    After that, connect the device and make a new lsmod. Comparing the
    different outputs might give a clue.
    </p>

    <A NAME="appendix-2"></A>
    <h3 align="center"> A2: Finding the event device</h3>
    <p>
    For many tasks it's necessary to find out the event device, something
    like /dev/input/event12, which is connected to your IR input.</p>
    <p>
    The first try is to invoke ir-keytable without any options:
    <pre>
	$ ir-keytable
	Found /sys/class/rc/rc0/ (/dev/input/event11) with:
	    Driver em28xx, table rc-pinnacle-pctv-hd
	    Supported protocols: NEC RC-5 RC-6
	    Enabled protocols: RC-5
	    Extra capabilities: <access denied>
    </pre>
    </p>
    <p>
    If the reported device matches your expectations you're done - here we
    have /dev/input/event11.</p>
    <p>
    If this doesn't work next try is to look in in /dev/input/by-id. If you
    find a device here which looks like your device, check where it's linked:
    <pre>
    $ ls /dev/input/by-id
    usb-Plus_More_Enterprise_LTD._USB-compliant_keyboard-event-kbd
    usb-_Home_Infrared_Transceiver_TS0013Yn-event-if00

    $ ls -l /dev/input/by-id/usb-eHome_Infrared_Transceiver_TS0013Yn-event-if00
    lrwxrwxrwx [cut] /dev/input/by-id/usb-eHome_Infrared_Transceiver_TS0013Yn-event-if00 -> ../event13
    </pre>
    So, here your interface is /dev/input/event13, and your're done.</p>
    <p>
    If this does not work, cat the input devices under /sys.
    <pre>
        $ cat /proc/bus/input/devices > foo
    </pre>
    Look in foo to find this snippet about your device:
    <pre>
	I: Bus=0003 Vendor=2013 Product=024f Version=0001
	N: Name="em28xx IR (em28174 #0)"
	P: Phys=usb-0000:00:1d.7-1/input0
	S: Sysfs=/devices/pci0000:00/0000:00:1d.7/usb1/1-1/rc/rc0/input14
    </pre>
    Here, the device is /dev/input/event14. </p>

    <A NAME="appendix-3"></A>
    <h3 align="center"> A3: Understanding the driver table</h3>
    <p>
    The <a href="http://www.lirc.org/html/table.html">driver list </a>
    gives some hints on the usage for each driver. The important columns
    are "Hardware", "Required LIRC kernel module", "lircd driver" and
    "Default lircd and lircmd config files".</p>
    <p>
    The "Hardware" column should be obvious. Note that it in many cases
    it refers to the receiver unit (e. g., the name reported by dmesg), not
    the name of the remote. So, before looking for a suitable driver
    use dmesg to find out the name as described in <a href="apppendix-2">
    Appendix 2</a></p>
    <p>
    The "lircd driver" refers to the argument you should give to lircd
    i. e., --driver=... You might need to check that the driver is
    available using <em>irrecord -H help</em>. If it's not listed here
    you need to rebuild lirc which is outside the scope of this document.
    </p>
    <p>
    The "Required LIRC kernel modules" refers to modules that are part of
    the linux kernel. Some of these are regular modules and should be
    available in any reasonable updated linux system. However, some of
    these modules are part of the staging drivers and might not be
    available on your system.</p>
    <p>
    To look for a particular module just search for it in /lib/modules
    e. g.,
    <pre>
        $ find  /lib/modules/$(uname -r) -name lirc_imon\*
        /lib/modules/3.12.7-300.fc20.i686/kernel/drivers/staging/media/lirc/lirc_imon.ko
    </pre>
    If it's listed, kernel should load it automatically on-demand. If it's
    not you have to build the staging drivers, also outside the scope of
    this document.  </p>
    <p>
    Unfortunately, the driver list does not provide information on the
    device which should be used for a particular driver. The only way
    to be sure is actually inspecting he sources. You might try to search
    the web before walking this path, though.</p>

  </BODY>
</HTML>
